<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Daily Non-Negotiable Tasks — Mobile</title>
<style>
  :root{
    --bg:#f7f7f8;
    --panel:#ffffff;
    --muted:#6b6f73;
    --accent:#4c5055; /* your logo color */
    --success:#2d9f6a;
    --danger:#e25353;
    --glass: rgba(76,80,85,0.06);
    --card-radius:16px;
  }
  html,body{height:100%;margin:0;font-family:Inter,system-ui,-apple-system,Segoe UI,Roboto,"Helvetica Neue",Arial;}
  body{background:var(--bg);color:#111;padding:16px;box-sizing:border-box}
  header{display:flex;align-items:center;justify-content:space-between;margin-bottom:12px;}
  .header-left{display:flex;flex-direction:column;}
  h1{font-size:20px;margin:0;color:var(--accent);}
  .date-row{font-size:13px;color:var(--muted);margin-top:4px;}
  .controls{display:flex;gap:8px;align-items:center;}
  button.btn{background:var(--accent);color:#fff;border:0;padding:10px 12px;border-radius:12px;font-weight:600;min-width:44px}
  button.ghost{background:transparent;color:var(--accent);border:1px solid var(--glass)}
  main{display:flex;flex-direction:column;gap:12px;}
  .summary{background:linear-gradient(180deg,#fff,#fbfbfb);padding:12px;border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,0.03);display:flex;justify-content:space-between;align-items:center}
  .summary .left{display:flex;flex-direction:column;}
  .big{font-size:16px;font-weight:700;color:var(--accent)}
  .small{font-size:12px;color:var(--muted)}
  .task-list{display:flex;flex-direction:column;gap:10px;margin-bottom:88px}
  .task-card{background:var(--panel);padding:12px;border-radius:14px;box-shadow:0 6px 18px rgba(0,0,0,0.03);display:flex;flex-direction:column;gap:8px}
  .task-row{display:flex;align-items:center;gap:8px;justify-content:space-between}
  .task-title{font-weight:700;color:#111}
  .task-meta{font-size:12px;color:var(--muted)}
  .task-actions{display:flex;gap:8px}
  .btn-action{padding:8px 10px;border-radius:10px;border:0;font-weight:700}
  .btn-start{background:linear-gradient(90deg,var(--accent),#2f3336);color:#fff}
  .btn-end{background:var(--danger);color:#fff}
  .btn-delete{background:transparent;border:1px solid var(--glass);color:var(--muted)}
  .progress{height:8px;background:var(--glass);border-radius:6px;overflow:hidden;margin-top:6px}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#6b6f73);width:0%}
  .fab{position:fixed;right:16px;bottom:18px;z-index:30}
  .fab button{width:56px;height:56px;border-radius:999px;font-size:28px;display:flex;align-items:center;justify-content:center;box-shadow:0 8px 24px rgba(76,80,85,0.14)}
  .inputs{display:flex;gap:8px}
  input[type="text"]{flex:1;padding:10px;border-radius:10px;border:1px solid var(--glass);font-size:15px}
  /* responsive touches */
  @media(min-width:700px){
    body{max-width:720px;margin:12px auto}
  }
  /* small utilities */
  .muted{color:var(--muted);font-size:12px}
  .tiny{font-size:11px;color:var(--muted)}
  .running-dot{width:10px;height:10px;border-radius:20px;background:var(--success);display:inline-block;margin-right:6px;box-shadow:0 4px 10px rgba(45,159,106,0.2)}
  footer.smallprint{position:fixed;left:16px;bottom:10px;font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<header>
  <div class="header-left">
    <h1>Daily Non-Negotiable Tasks</h1>
    <div class="date-row" id="date-display">Loading date…</div>
  </div>
  <div class="controls">
    <button class="btn ghost" id="prev-day" title="Previous day">‹</button>
    <button class="btn" id="today" title="Jump to today">Today</button>
    <button class="btn ghost" id="next-day" title="Next day">›</button>
  </div>
</header>

<main>
  <div class="summary" aria-live="polite">
    <div class="left">
      <div class="big" id="total-time">Total: 00:00:00</div>
      <div class="small" id="total-percent">0.00% of 24 hours</div>
    </div>
    <div style="display:flex;flex-direction:column;align-items:flex-end;gap:6px">
      <button class="btn ghost" id="export-csv">Export CSV</button>
      <button class="btn" id="clear-day" title="Clear tasks for shown day">Clear</button>
    </div>
  </div>

  <div class="inputs">
    <input id="new-task-name" type="text" placeholder="Add a new task (e.g., 'Morning routine')" aria-label="New task name"/>
    <button class="btn" id="add-task">Add</button>
  </div>

  <section class="task-list" id="task-list" aria-live="polite">
    <!-- task cards inserted here -->
  </section>
</main>

<div class="fab" title="Add task quick">
  <button id="fab-add">+</button>
</div>

<footer class="smallprint">Saved locally (localStorage). Works offline.</footer>

<script>
/*
  Mobile-first Task Timer
  Data Model:
  storage key: "dnt_tasks:<YYYY-MM-DD>" => { date: 'YYYY-MM-DD', tasks: [ {id, name, sessions: [{startISO,endISO|null}], createdAt } ] }
*/

(() => {
  const ONE_DAY_SECONDS = 24 * 3600;
  const STORAGE_PREFIX = 'dnt_tasks:';
  const dateDisplay = document.getElementById('date-display');
  const taskListEl = document.getElementById('task-list');
  const totalTimeEl = document.getElementById('total-time');
  const totalPercentEl = document.getElementById('total-percent');
  const newTaskInput = document.getElementById('new-task-name');
  const addTaskBtn = document.getElementById('add-task');
  const fabAdd = document.getElementById('fab-add');
  const prevBtn = document.getElementById('prev-day');
  const nextBtn = document.getElementById('next-day');
  const todayBtn = document.getElementById('today');
  const exportCsvBtn = document.getElementById('export-csv');
  const clearDayBtn = document.getElementById('clear-day');

  // state
  let currentDate = new Date(); // will be normalized to date only
  let data = { date: isoDate(currentDate), tasks: [] };
  let liveTimerInterval = null;

  // util helpers
  function isoDate(d){
    const t = new Date(d);
    t.setMinutes(t.getMinutes() - t.getTimezoneOffset()); // adjust to local ISO date
    return t.toISOString().slice(0,10);
  }
  function nowISO(){ return new Date().toISOString(); }
  function uid(prefix='id'){ return prefix + '-' + Math.random().toString(36).slice(2,10); }
  function readStorage(dateKey){
    const raw = localStorage.getItem(STORAGE_PREFIX + dateKey);
    if(!raw) return { date: dateKey, tasks: [] };
    try { return JSON.parse(raw); } catch(e) { return { date: dateKey, tasks: [] }; }
  }
  function writeStorage(obj){
    localStorage.setItem(STORAGE_PREFIX + obj.date, JSON.stringify(obj));
  }
  function secondsToHHMMSS(sec){
    sec = Math.max(0, Math.round(sec));
    const h = Math.floor(sec/3600);
    const m = Math.floor((sec%3600)/60);
    const s = sec%60;
    return [h,m,s].map(n=>String(n).padStart(2,'0')).join(':');
  }
  function durationSecondsForSessions(sessions, dayIso = null){
    // sessions: [{start, end|null}] ISO strings
    let total = 0;
    for(const s of sessions){
      const start = s.start ? new Date(s.start) : null;
      const end = s.end ? new Date(s.end) : new Date(); // if running -> now
      if(!start) continue;
      if(dayIso){
        // ensure we only count portion that belongs to dayIso
        const dayStart = new Date(dayIso + 'T00:00:00');
        const dayEnd = new Date(dayIso + 'T23:59:59.999');
        const segStart = start > dayStart ? start : dayStart;
        const segEnd = end < dayEnd ? end : dayEnd;
        if(segEnd > segStart) total += (segEnd - segStart) / 1000;
      } else {
        if(end > start) total += (end - start) / 1000;
      }
    }
    return Math.max(0, total);
  }
  function percentOfDaySeconds(sec){ return (sec / (24*3600)) * 100; }

  // load and render
  function loadDate(d){
    currentDate = new Date(d);
    // normalize
    data = readStorage(isoDate(currentDate));
    render();
    startLiveTimer();
  }

  function saveData(){
    writeStorage(data);
  }

  function render(){
    const iso = isoDate(currentDate);
    dateDisplay.textContent = new Date(currentDate).toLocaleDateString(undefined, { weekday: 'short', month:'short', day:'numeric', year:'numeric' });
    taskListEl.innerHTML = '';
    // sort tasks by createdAt
    data.tasks.sort((a,b)=> (a.createdAt||'').localeCompare(b.createdAt||''));
    // render each task
    for(const t of data.tasks){
      const card = document.createElement('article');
      card.className = 'task-card';
      card.dataset.id = t.id;

      const row = document.createElement('div');
      row.className = 'task-row';
      // left: title and running indicator
      const left = document.createElement('div');
      left.style.display='flex'; left.style.flexDirection='column';
      const titleRow = document.createElement('div');
      titleRow.style.display='flex'; titleRow.style.alignItems='center'; titleRow.style.gap='8px';
      const running = hasRunningSession(t);
      if(running){
        const dot = document.createElement('span');
        dot.className = 'running-dot';
        titleRow.appendChild(dot);
      }
      const title = document.createElement('span');
      title.className = 'task-title';
      // editable title
      title.contentEditable = true;
      title.spellcheck = false;
      title.innerText = t.name || 'Untitled task';
      title.style.outline = 'none';
      title.addEventListener('blur', (e)=>{
        t.name = title.innerText.trim() || 'Untitled task';
        saveData();
      });
      title.addEventListener('keydown', (ev)=> {
        if(ev.key === 'Enter'){ ev.preventDefault(); title.blur(); }
      });
      titleRow.appendChild(title);
      left.appendChild(titleRow);

      // meta line
      const meta = document.createElement('div');
      meta.className = 'task-meta';
      const dur = durationSecondsForSessions(t.sessions || [], iso);
      const endStartText = lastSessionTimesText(t, iso);
      meta.innerText = `${endStartText} • ${secondsToHHMMSS(dur)} • ${percentOfDaySeconds(dur).toFixed(2)}%`;
      left.appendChild(meta);

      row.appendChild(left);

      // actions
      const actions = document.createElement('div');
      actions.className = 'task-actions';
      // start btn
      const startBtn = document.createElement('button');
      startBtn.className = 'btn-action btn-start';
      startBtn.innerText = running ? 'Running' : 'Start';
      startBtn.disabled = running; // disable start if running for that task
      startBtn.addEventListener('click', ()=> {
        startSession(t);
      });
      // end btn
      const endBtn = document.createElement('button');
      endBtn.className = 'btn-action btn-end';
      endBtn.innerText = 'End';
      endBtn.addEventListener('click', ()=> {
        endSession(t);
      });
      // delete btn
      const delBtn = document.createElement('button');
      delBtn.className = 'btn-action btn-delete';
      delBtn.innerText = 'Delete';
      delBtn.addEventListener('click', ()=>{
        if(confirm('Delete this task and its sessions?')) {
          data.tasks = data.tasks.filter(x=>x.id !== t.id);
          saveData();
          render();
        }
      });

      actions.appendChild(startBtn);
      actions.appendChild(endBtn);
      actions.appendChild(delBtn);
      row.appendChild(actions);

      card.appendChild(row);

      // progress bar
      const progressWrap = document.createElement('div');
      progressWrap.className = 'progress';
      const progressInner = document.createElement('i');
      // percent of day
      const pct = Math.min(100, percentOfDaySeconds(dur));
      progressInner.style.width = pct + '%';
      progressWrap.appendChild(progressInner);
      card.appendChild(progressWrap);

      taskListEl.appendChild(card);
    }

    // totals
    const totalSec = data.tasks.reduce((acc,t)=> acc + durationSecondsForSessions(t.sessions || [], iso), 0);
    totalTimeEl.textContent = 'Total: ' + secondsToHHMMSS(totalSec);
    totalPercentEl.textContent = percentOfDaySeconds(totalSec).toFixed(2) + '% of 24 hours';

    // update add input placeholder to remind day
    newTaskInput.placeholder = `Add a new task for ${iso}`;
  }

  function lastSessionTimesText(task, dayIso){
    // return "Start: HH:MM End: HH:MM" for last session that intersects dayIso
    const iso = dayIso || isoDate(currentDate);
    const sessions = (task.sessions || []).slice().reverse();
    for(const s of sessions){
      const start = s.start ? new Date(s.start) : null;
      const end = s.end ? new Date(s.end) : (s.start ? new Date() : null);
      if(!start) continue;
      const dayStart = new Date(iso + 'T00:00:00');
      const dayEnd = new Date(iso + 'T23:59:59.999');
      const segStart = start > dayStart ? start : dayStart;
      const segEnd = end < dayEnd ? end : dayEnd;
      if(segEnd > segStart){
        return `Start: ${segStart.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'})} • End: ${s.end ? segEnd.toLocaleTimeString([], {hour:'2-digit',minute:'2-digit'}) : '—'}`;
      }
    }
    return 'Start: — • End: —';
  }

  // session logic
  function hasRunningSession(task){
    return (task.sessions||[]).some(s => s.start && !s.end);
  }
  function startSession(task){
    if(hasRunningSession(task)){
      alert('This task already has a running session. End it first before starting another for this task.');
      return;
    }
    // create new session with start now
    const s = { start: nowISO(), end: null };
    task.sessions = task.sessions || [];
    task.sessions.push(s);
    saveData();
    render();
  }
  function endSession(task){
    // find last running session in this task and end it with now, splitting across days when needed
    const sessions = task.sessions || [];
    const idx = sessions.map(s=>s.start && !s.end ? 1:0).lastIndexOf(1);
    if(idx === -1){
      alert('No running session found for this task. Press Start first.');
      return;
    }
    const s = sessions[idx];
    const endTime = new Date();
    const startTime = new Date(s.start);
    // if session crosses midnight, we split: keep original session end at 23:59:59.999 of start day, and create a new session for next day(s)
    if(startTime.toDateString() !== endTime.toDateString()){
      // end original at 23:59:59.999 of start day
      const endOfStartDay = new Date(startTime);
      endOfStartDay.setHours(23,59,59,999);
      s.end = endOfStartDay.toISOString();
      // now create remainder session(s) for subsequent days until endTime
      let nextStart = new Date(startTime);
      nextStart.setDate(nextStart.getDate() + 1);
      nextStart.setHours(0,0,0,0);
      // If endTime is same day as nextStart padding (i.e., crosses 1 day only), create one session
      if(nextStart.toDateString() === endTime.toDateString()){
        task.sessions.push({ start: nextStart.toISOString(), end: endTime.toISOString() });
      } else {
        // multiple-day crossing (rare): add intermediate full-day sessions
        let cursorStart = new Date(nextStart);
        while(cursorStart.toDateString() !== endTime.toDateString()){
          const fullDayEnd = new Date(cursorStart);
          fullDayEnd.setHours(23,59,59,999);
          task.sessions.push({ start: cursorStart.toISOString(), end: fullDayEnd.toISOString() });
          cursorStart.setDate(cursorStart.getDate() + 1);
          cursorStart.setHours(0,0,0,0);
        }
        // final partial day
        task.sessions.push({ start: cursorStart.toISOString(), end: endTime.toISOString() });
      }
    } else {
      // same day -> just set end
      s.end = endTime.toISOString();
    }
    saveData();
    render();
  }

  // add task
  function addTask(name){
    const trimmed = (name || '').trim();
    if(!trimmed) return;
    const newTask = {
      id: uid('task'),
      name: trimmed,
      sessions: [],
      createdAt: new Date().toISOString()
    };
    data.tasks.push(newTask);
    saveData();
    render();
    newTaskInput.value = '';
    newTaskInput.focus();
  }

  // live timer tick (updates running durations)
  function startLiveTimer(){
    if(liveTimerInterval) clearInterval(liveTimerInterval);
    liveTimerInterval = setInterval(()=> {
      // update UI for running sessions without writing storage on every tick (to reduce writes)
      // but we will update totals and session meta so user sees live time
      updateLiveDisplays();
    }, 1000);
  }
  function updateLiveDisplays(){
    const iso = isoDate(currentDate);
    // update each card's meta and progress and totals
    const cards = document.querySelectorAll('.task-card');
    data.tasks.forEach(t => {
      // find corresponding card
      const card = Array.from(cards).find(c => c.dataset.id === t.id);
      if(!card) return;
      const meta = card.querySelector('.task-meta');
      const dur = durationSecondsForSessions(t.sessions || [], iso);
      meta.innerText = `${lastSessionTimesText(t, iso)} • ${secondsToHHMMSS(dur)} • ${percentOfDaySeconds(dur).toFixed(2)}%`;
      const prog = card.querySelector('.progress > i');
      if(prog) { prog.style.width = Math.min(100, percentOfDaySeconds(dur)) + '%'; }
      const btnStart = card.querySelector('.btn-start');
      const running = hasRunningSession(t);
      btnStart.disabled = running;
      btnStart.innerText = running ? 'Running' : 'Start';
    });
    // totals
    const totalSec = data.tasks.reduce((acc,t)=> acc + durationSecondsForSessions(t.sessions || [], iso), 0);
    totalTimeEl.textContent = 'Total: ' + secondsToHHMMSS(totalSec);
    totalPercentEl.textContent = percentOfDaySeconds(totalSec).toFixed(2) + '% of 24 hours';
  }

  // export CSV for current day
  function exportCsvForDate(dateIso){
    const header = ['Task Name','Session Start (ISO)','Session End (ISO)','Duration (seconds)','Duration (HH:MM:SS)','Percent of 24h'];
    const rows = [header];
    const dayData = readStorage(dateIso);
    for(const t of dayData.tasks){
      const sessions = t.sessions || [];
      for(const s of sessions){
        // only include sessions that intersect dateIso (split logic ensures this)
        const start = s.start || '';
        const end = s.end || '';
        // compute duration within that day
        const dur = durationSecondsForSessions([s], dateIso);
        if(dur <= 0) continue;
        rows.push([t.name, start, end, String(Math.round(dur)), secondsToHHMMSS(dur), percentOfDaySeconds(dur).toFixed(4) + '%']);
      }
    }
    // CSV
    const csv = rows.map(r => r.map(cell => `"${String(cell).replace(/"/g,'""')}"`).join(',')).join('\n');
    const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `dnt_${dateIso}.csv`;
    a.click();
    URL.revokeObjectURL(url);
  }

  // clear tasks for current date
  function clearDay(dateIso){
    if(!confirm('Clear all tasks & sessions for this day? This cannot be undone.')) return;
    localStorage.removeItem(STORAGE_PREFIX + dateIso);
    data = readStorage(dateIso);
    render();
  }

  // navigation
  function shiftDays(delta){
    const d = new Date(currentDate);
    d.setDate(d.getDate() + delta);
    loadDate(d);
  }
  function jumpToToday(){
    loadDate(new Date());
  }

  // wiring events
  addTaskBtn.addEventListener('click', ()=> addTask(newTaskInput.value));
  fabAdd.addEventListener('click', ()=> addTask(newTaskInput.value || 'New Task'));
  newTaskInput.addEventListener('keydown', (e)=> { if(e.key === 'Enter') addTask(newTaskInput.value); });
  prevBtn.addEventListener('click', ()=> shiftDays(-1));
  nextBtn.addEventListener('click', ()=> shiftDays(1));
  todayBtn.addEventListener('click', ()=> jumpToToday());
  exportCsvBtn.addEventListener('click', ()=> exportCsvForDate(isoDate(currentDate)));
  clearDayBtn.addEventListener('click', ()=> clearDay(isoDate(currentDate)));

  // initial load
  loadDate(new Date());

  // expose for debugging (optional)
  window.dnt = {
    loadDate,
    readStorage,
    writeStorage,
    getData: ()=> data
  };

})();
</script>
</body>
</html>